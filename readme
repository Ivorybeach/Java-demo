
1.Collection
集合的root interface(不包括Map)，继承了Iterator，定义了add(),remove()这些方法，不同类型的集合，对collection中方法的实现有所不同。

2.Collections
Collections给我的感觉就是一个工具类，里面定义了操作集合的方法，一般来说Collection的子类集合(arrayList,hashMap等)都是非线程安全的，
就可以通过Collections来获得相应的线程安全类，在保证线程安全的同时性能当然会受到影响。

Collection和Collections的区别：Collection是集合最基础的定义，而Collections提供了操作集合的方法，除了长得像点，根本就是两回事。

3.List
有序集合(sequence)，允许重复(duplicate)元素，允许多个null元素。
值得提一嘴的是，List有一个单独的迭代器：ListIterator

4.ArrayList
非线程安全。可以通过Collections获得一个synchronizedList。
有序，允许重复元素和null元素。
继承了List和AbstractList，是一个长度可变的数组(resizable-array)。默认长度为10。
底层就是用数组来实现的，这决定了其查询快的提点。当在arrayList添加元素时，其数组长度会自动增长。
在添加新元素时超过arrayList原始容量，采用扩充方案进行扩容。
ArrayList的capacity就是数组的size。
源码中已经说明： (This class is roughly equivalent to Vector, except that it is unsynchronized.)
Vector(已过时)是线程安全的ArrayList，其中所有方法都加了synchronized。此外二者的区别还在于ensureCapacity，Vector的扩容方案为原来两倍。

5.LinkedList
底层实现是双向链表(Doubly-linked)，所以查询慢，增删快。因为在查询时只能从头一个一个遍历元素。
在eclipse中查看LinkedList类的outline，可以看到有first，last，node这些，可以实锤是链表。
有序，允许重复元素和Null元素。
非线程安全，同样是通过collections.synochronizedList(list)得到一个线程安全的linkedList。


6.Set
不可重复(no dulicate elements)，Set判断元素是否重复依据的是equals()的比较结果，但还要考虑到hashCode。
无序，最多允许一个null元素。
对于重复元素的判断，要同时判断equals()和hashCode。
Set接口的底层是根据Map接口实现的：TreeSet-TreeMap,HashSet-HashMap
HashSet中的元素就是HashMap的key，key不可以重复，可以为null，对应HashSet元素的属性，可以为null，不可以重复。

7.HashSet
继承自Set接口，其底层实际是一个HashMap，查看其源码可以看到HashSet的构造方法是直接new一个HashMap(或是LinkedHashMap)出来。
允许null element。可以指定初始容量int initialCapacity。
非线程安全，可以通过collections类将一个hashSet转换为线程安全的synchronizedSet：
Set<?> hashSet = new HashSet<?>;
Set<?> safeHashSet = Collections.SynchronizedSet(hashSet);
不过相应的，hashSet的性能也会受到影响，一般情况下，还是使用java.util.concurrent包中的类来解决集合的并发问题。
HashSet中的内容是不可重复的，HashSet判断对象是否重复的是根据equals()和hashCode来判断：
当hashCode相同，表示同一对象。
当hashCode不同，用equals()方法来比较，返回为ture，表示相同元素，返回false，表示不同元素。
如果存入的是自定义对象，为了保证hashSet对对象是否重复的正确判断，应该在po类中重写hashCode和equals()方法

8.LinkedHashSet
继承了HashSet和Set接口，底层为双层链表(doubly-linked)+hash算法

9.TreeSet
底层是通过treeMap来实现的，可以看到直接new一个treeMap出来。
存入其中的元素会被排序，通过比较器Comparator或者Comparable接口的compareTo()方法。
元素不可重复，非线程安全。
TreeSet在使用的时候必须要传入Comparator或者元素必须继承Comparable接口并复写CompareTo()方法，可看作是定义排序规则。
ps：集合中存放的都是对象，TreeSet存入简单类型(int,char)等，也会转成Integer，而Integer类本身已经实现了Comparable接口，复写了compareTo()
方法，所以在存入自定义对象时，一定要记得上面的要求。

10.Map
key-value形式，key不可以重复，可以为null（只能有一个？这样说是因为HashSet只能有一个null）
严格来说 Map 并不是一个集合，而是两个集合之间 的映射关系。这两个集合每一条数据通过映射关系，我们可以看成是一条数据。
即 Entry(key,value）。Map 可以看成是由多个 Entry 组成。
注意Map并没有继承Iterator接口，其继承类也都没有实现Iterator接口
注意一个方法：Set<Map.Entry<K, V>> entrySet(),Entry是用来存放键值对(key-value pair)的
这个方法返回一个泛型为Entry的Set集合，因为Map没有实现Iteraotr接口，所以可以用Iterator来遍历Set中的Entry

11.HashMap
允许key和value均为null，key不可以重复，只能有一个null
非线程安全，Connections.synchronizedMap()
在创建HashMap时可以加入initial capacity、load factor两个参数：
initial capacity:初始容量，默认16
load factor:决定在元素达到多少时开始扩容，默认0.75


12.hashTable
线程安全，不允许任意key和value为Null

12.LinkedHashMap
继承了HashMap和Map，允许key和value均为null，

13.TreeMap
非线程安全
会对元素根据key进行排序
存入自定义对象需要Comparator或是实现Comparable接口






hashSet、hashMap
	hashSet的底层实现是hashMap,故以下通向适用于hashMap
	hashSet不允许元素重复，判断要存入的元素是否重复使用hashCode()和equals()方法
	当hashCode相同时，表示同一元素
	当hashcode不同，比较equal()
		equal()返回为true，那么两个对象的hashCode一定相同，所以表示相同元素
		equal()返回为false，表示不同元素，这种情况下将元素存入链表中，应当避免这种情况
	
	如果在hashSet中存入的是自定义对象，为了确保hashSet的元素不重复，需要重写equal()和hashCode()进行判断
	

treeSet、treeMap
	treeSet实现了排序，需要其中的对象重写compareTo()定义排序规则
	集合中存入的只能是对象，存入其中的基本数据类型如int会转化为Integer
	Integer这些类都继承了Comparable接口，同时重写了compareTo()方法
	当在treeSet、treeMap中存入自定义对象时，必须要：
		1.继承Comparable()接口重写CompareTo()方法
		2.直接使用比较器Comparator重写ComparaTo()方法
	注意：存入自定义对象时，必须使用上述两种方式之一重写ComparaTo()，定义排序规则
	
arrayList的线程安全类是Vector，hashMap的线程安全类是HashTable;concurrentHashMap线程安全、效率高于hashTable
但是Vector和HashTable效率低下，且易引发线程安全问题
jdk1.5后引入java.util.Concurrent包来提供效率高的同步集合
	

	
	