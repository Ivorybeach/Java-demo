四种基本IO：
	InputStream、OutputStream 基于字节操作的 IO，操作字符，数字，二进制图片
	Writer、Reader 基于字符操作的 IO，操作中文，字符
	File 基于磁盘操作的 IO
	Socket 基于网络操作的 IO

File类：实现Synchorizable接口和Comparable接口
	
	abstarct pathname:这玩意到底是什么？我的理解是，就是new File(String pathname)中的pathname
	原因：构建一个file后，调用file.isAbsolute()，判断给出的abstract pathname是否为绝对路径，由这个方法的说明可以知道：
	传递的pathname参数就是abstract pathname。
	
	File.separator分割符

RandomAccessFile:

Piped IO:
	看一下字节流能否转换为字符流
	

传统IO：
	File：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。
	InputStream：抽象类、基于字节的输入操作、是所有输入流的父类、定义了所有输入流都具有的共同特征。
	OutputStream：抽象类、基于字节的输出操作、是所有输出流的父类、定义了所有输出流都具有的共同特征。
	Reader：抽象类、基于字符的输入操作；
	Writer：抽象类、基于字符的输出操作；
	RandomAccessFile：功能丰富，可以从文件的任意位置进行存取（输入输出）操作；

Writer:
	字符流(character streams)抽象类，定义了write(),flush(),close()等抽象方法
	Writer的不同实现类，针对不同的操作对象和目标对象，(file,管道，网络)，而对上述方法进行不同的实现
	
OutputStreamWriter：
	继承Writer，作用是将字节流转换为字符流.
	源码：OutputStreamWriter is bridge from character stream to byte stream.
	可以指定charset
	
FileWriter
	继承OutputStreamWriter
	以character来写入file
	其charset和buffer大小为默认，不可通过构造器指定

StringWriter,StringReader：操作对象为字符串

BufferWriter,BufferReader,BufferOutputStream,BufferInputStream:
	其他流可以通过此类转换为使用buffer的流
	在对流进行写入时提供一个buffer来提高IO效率。在进行磁盘或网络IO时，原始的InputStream对数据读取的过程都是一个字节一个字节操作的，
	而BufferedInputStream在其内部提供了一个buffer，在读数据时，会一次读取一大块数据到buffer中，这样比单字节的操作效率要高的多，
	特别是进程磁盘IO和对大量数据进行读写的时候。
	BufferReader额外提供readline()方法，可以读一行


缓冲区：
	避免对磁盘的重复读写，而是将内容读到一定大小的缓冲区中(缓冲区在内存)，等缓冲区满之后一次性写入硬盘；
	flush()为清空缓冲区，在缓冲区未满时，强制将缓冲区内容写入硬盘；
	
flush()
	为输出流Writer,OutPutStream所有
	flush()意思是把缓冲区的内容强制的写出。 因为操作系统的某些机制，为了防止一直不停地磁盘读写，所以有了延迟写入的概念,
	(注意不要和frush()刷新混淆了)，主要用在IO中，即清空缓冲区数据，一般在读写流(stream)的时候，数据是先被读到了内存中，再把数据
	写到文件中，当你数据读完的时候不代表你的数据已经写完了，因为还有一部分有可能会留在内存这个缓冲区中。这时候如果你调用了close()方法
	关闭了读写流，那么这部分数据就会丢失，所以应该在关闭读写流之前先flush()。
	所以flush()在buffered流中使用才有意义

InputStream:
	read()	//返回下一个byte,如果最后一个返回-1
	read(byte[] b)	//将内容读取到byte中





字节流：
	inputStream 读
	outputStream 写
字符流：
	Reader 读
	Writer 写
	
字节/字符流的操作对象：
	文件file
	管道pipe
	网络连接
	内存缓存 
	